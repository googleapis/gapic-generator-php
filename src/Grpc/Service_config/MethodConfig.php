<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: grpc/service_config/service_config.proto

namespace Grpc\Service_config;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Configuration for a method.
 *
 * Generated from protobuf message <code>grpc.service_config.MethodConfig</code>
 */
class MethodConfig extends \Google\Protobuf\Internal\Message
{
    /**
     * Generated from protobuf field <code>repeated .grpc.service_config.MethodConfig.Name name = 1;</code>
     */
    private $name;
    /**
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     */
    protected $wait_for_ready = null;
    /**
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration timeout = 3;</code>
     */
    protected $timeout = null;
    /**
     * The maximum allowed payload size for an individual request or object in a
     * stream (client->server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minimum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     *
     * Generated from protobuf field <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     */
    protected $max_request_message_bytes = null;
    /**
     * The maximum allowed payload size for an individual response or object in a
     * stream (server->client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minimum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     *
     * Generated from protobuf field <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     */
    protected $max_response_message_bytes = null;
    protected $retry_or_hedging_policy;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Grpc\Service_config\MethodConfig\Name[]|\Google\Protobuf\Internal\RepeatedField $name
     *     @type \Google\Protobuf\BoolValue $wait_for_ready
     *           Whether RPCs sent to this method should wait until the connection is
     *           ready by default. If false, the RPC will abort immediately if there is
     *           a transient failure connecting to the server. Otherwise, gRPC will
     *           attempt to connect until the deadline is exceeded.
     *           The value specified via the gRPC client API will override the value
     *           set here. However, note that setting the value in the client API will
     *           also affect transient errors encountered during name resolution, which
     *           cannot be caught by the value here, since the service config is
     *           obtained by the gRPC client via name resolution.
     *     @type \Google\Protobuf\Duration $timeout
     *           The default timeout in seconds for RPCs sent to this method. This can be
     *           overridden in code. If no reply is received in the specified amount of
     *           time, the request is aborted and a DEADLINE_EXCEEDED error status
     *           is returned to the caller.
     *           The actual deadline used will be the minimum of the value specified here
     *           and the value set by the application via the gRPC client API.  If either
     *           one is not set, then the other will be used.  If neither is set, then the
     *           request has no deadline.
     *     @type \Google\Protobuf\UInt32Value $max_request_message_bytes
     *           The maximum allowed payload size for an individual request or object in a
     *           stream (client->server) in bytes. The size which is measured is the
     *           serialized payload after per-message compression (but before stream
     *           compression) in bytes. This applies both to streaming and non-streaming
     *           requests.
     *           The actual value used is the minimum of the value specified here and the
     *           value set by the application via the gRPC client API.  If either one is
     *           not set, then the other will be used.  If neither is set, then the
     *           built-in default is used.
     *           If a client attempts to send an object larger than this value, it will not
     *           be sent and the client will see a ClientError.
     *           Note that 0 is a valid value, meaning that the request message
     *           must be empty.
     *     @type \Google\Protobuf\UInt32Value $max_response_message_bytes
     *           The maximum allowed payload size for an individual response or object in a
     *           stream (server->client) in bytes. The size which is measured is the
     *           serialized payload after per-message compression (but before stream
     *           compression) in bytes. This applies both to streaming and non-streaming
     *           requests.
     *           The actual value used is the minimum of the value specified here and the
     *           value set by the application via the gRPC client API.  If either one is
     *           not set, then the other will be used.  If neither is set, then the
     *           built-in default is used.
     *           If a server attempts to send an object larger than this value, it will not
     *           be sent, and a ServerError will be sent to the client instead.
     *           Note that 0 is a valid value, meaning that the response message
     *           must be empty.
     *     @type \Grpc\Service_config\MethodConfig\RetryPolicy $retry_policy
     *     @type \Grpc\Service_config\MethodConfig\HedgingPolicy $hedging_policy
     * }
     */
    public function __construct($data = null)
    {
        \GPBMetadata\Grpc\ServiceConfig\ServiceConfig::initOnce();
        parent::__construct($data);
    }

    /**
     * Generated from protobuf field <code>repeated .grpc.service_config.MethodConfig.Name name = 1;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * Generated from protobuf field <code>repeated .grpc.service_config.MethodConfig.Name name = 1;</code>
     * @param \Grpc\Service_config\MethodConfig\Name[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setName($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Grpc\Service_config\MethodConfig\Name::class);
        $this->name = $arr;

        return $this;
    }

    /**
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     * @return \Google\Protobuf\BoolValue
     */
    public function getWaitForReady()
    {
        return isset($this->wait_for_ready) ? $this->wait_for_ready : null;
    }

    public function hasWaitForReady()
    {
        return isset($this->wait_for_ready);
    }

    public function clearWaitForReady()
    {
        unset($this->wait_for_ready);
    }

    /**
     * Returns the unboxed value from <code>getWaitForReady()</code>

     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     * @return bool|null
     */
    public function getWaitForReadyUnwrapped()
    {
        return $this->readWrapperValue("wait_for_ready");
    }

    /**
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     * @param \Google\Protobuf\BoolValue $var
     * @return $this
     */
    public function setWaitForReady($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\BoolValue::class);
        $this->wait_for_ready = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\BoolValue object.

     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     * @param bool|null $var
     * @return $this
     */
    public function setWaitForReadyUnwrapped($var)
    {
        $this->writeWrapperValue("wait_for_ready", $var);
        return $this;
    }

    /**
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration timeout = 3;</code>
     * @return \Google\Protobuf\Duration
     */
    public function getTimeout()
    {
        return isset($this->timeout) ? $this->timeout : null;
    }

    public function hasTimeout()
    {
        return isset($this->timeout);
    }

    public function clearTimeout()
    {
        unset($this->timeout);
    }

    /**
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration timeout = 3;</code>
     * @param \Google\Protobuf\Duration $var
     * @return $this
     */
    public function setTimeout($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Duration::class);
        $this->timeout = $var;

        return $this;
    }

    /**
     * The maximum allowed payload size for an individual request or object in a
     * stream (client->server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minimum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     *
     * Generated from protobuf field <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     * @return \Google\Protobuf\UInt32Value
     */
    public function getMaxRequestMessageBytes()
    {
        return isset($this->max_request_message_bytes) ? $this->max_request_message_bytes : null;
    }

    public function hasMaxRequestMessageBytes()
    {
        return isset($this->max_request_message_bytes);
    }

    public function clearMaxRequestMessageBytes()
    {
        unset($this->max_request_message_bytes);
    }

    /**
     * Returns the unboxed value from <code>getMaxRequestMessageBytes()</code>

     * The maximum allowed payload size for an individual request or object in a
     * stream (client->server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minimum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     *
     * Generated from protobuf field <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     * @return int|null
     */
    public function getMaxRequestMessageBytesUnwrapped()
    {
        return $this->readWrapperValue("max_request_message_bytes");
    }

    /**
     * The maximum allowed payload size for an individual request or object in a
     * stream (client->server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minimum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     *
     * Generated from protobuf field <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     * @param \Google\Protobuf\UInt32Value $var
     * @return $this
     */
    public function setMaxRequestMessageBytes($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\UInt32Value::class);
        $this->max_request_message_bytes = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\UInt32Value object.

     * The maximum allowed payload size for an individual request or object in a
     * stream (client->server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minimum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     *
     * Generated from protobuf field <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     * @param int|null $var
     * @return $this
     */
    public function setMaxRequestMessageBytesUnwrapped($var)
    {
        $this->writeWrapperValue("max_request_message_bytes", $var);
        return $this;
    }

    /**
     * The maximum allowed payload size for an individual response or object in a
     * stream (server->client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minimum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     *
     * Generated from protobuf field <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     * @return \Google\Protobuf\UInt32Value
     */
    public function getMaxResponseMessageBytes()
    {
        return isset($this->max_response_message_bytes) ? $this->max_response_message_bytes : null;
    }

    public function hasMaxResponseMessageBytes()
    {
        return isset($this->max_response_message_bytes);
    }

    public function clearMaxResponseMessageBytes()
    {
        unset($this->max_response_message_bytes);
    }

    /**
     * Returns the unboxed value from <code>getMaxResponseMessageBytes()</code>

     * The maximum allowed payload size for an individual response or object in a
     * stream (server->client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minimum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     *
     * Generated from protobuf field <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     * @return int|null
     */
    public function getMaxResponseMessageBytesUnwrapped()
    {
        return $this->readWrapperValue("max_response_message_bytes");
    }

    /**
     * The maximum allowed payload size for an individual response or object in a
     * stream (server->client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minimum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     *
     * Generated from protobuf field <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     * @param \Google\Protobuf\UInt32Value $var
     * @return $this
     */
    public function setMaxResponseMessageBytes($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\UInt32Value::class);
        $this->max_response_message_bytes = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\UInt32Value object.

     * The maximum allowed payload size for an individual response or object in a
     * stream (server->client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minimum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     *
     * Generated from protobuf field <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     * @param int|null $var
     * @return $this
     */
    public function setMaxResponseMessageBytesUnwrapped($var)
    {
        $this->writeWrapperValue("max_response_message_bytes", $var);
        return $this;
    }

    /**
     * Generated from protobuf field <code>.grpc.service_config.MethodConfig.RetryPolicy retry_policy = 6;</code>
     * @return \Grpc\Service_config\MethodConfig\RetryPolicy
     */
    public function getRetryPolicy()
    {
        return $this->readOneof(6);
    }

    public function hasRetryPolicy()
    {
        return $this->hasOneof(6);
    }

    /**
     * Generated from protobuf field <code>.grpc.service_config.MethodConfig.RetryPolicy retry_policy = 6;</code>
     * @param \Grpc\Service_config\MethodConfig\RetryPolicy $var
     * @return $this
     */
    public function setRetryPolicy($var)
    {
        GPBUtil::checkMessage($var, \Grpc\Service_config\MethodConfig\RetryPolicy::class);
        $this->writeOneof(6, $var);

        return $this;
    }

    /**
     * Generated from protobuf field <code>.grpc.service_config.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
     * @return \Grpc\Service_config\MethodConfig\HedgingPolicy
     */
    public function getHedgingPolicy()
    {
        return $this->readOneof(7);
    }

    public function hasHedgingPolicy()
    {
        return $this->hasOneof(7);
    }

    /**
     * Generated from protobuf field <code>.grpc.service_config.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
     * @param \Grpc\Service_config\MethodConfig\HedgingPolicy $var
     * @return $this
     */
    public function setHedgingPolicy($var)
    {
        GPBUtil::checkMessage($var, \Grpc\Service_config\MethodConfig\HedgingPolicy::class);
        $this->writeOneof(7, $var);

        return $this;
    }

    /**
     * @return string
     */
    public function getRetryOrHedgingPolicy()
    {
        return $this->whichOneof("retry_or_hedging_policy");
    }
}
